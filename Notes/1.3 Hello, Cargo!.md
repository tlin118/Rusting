## Hello, Cargo!
- Cargo is Rust's build and package manager
	- building code
	- downloading and building libraries (*dependencies*)

ㅤ
- check whether Cargo is installed
```console
$ cargo --version
```
---
### Creating a Project with Cargo
```console
$ cargo new hello_cargo
$ cd hello_cargo
```
- first command creates a new directory and project called *hello_cargo*
	- project name: *hello_cargo*
	- Cargo creates its files in a directly of the same name

Filename: [[Projects/hello_cargo/Cargo.toml|Cargo.toml]]
```toml
# Listing 1-2: Contents of `Cargo.toml` generated by `cargo new`
[package] name = "hello_cargo" 
version = "0.1.0" 
edition = "2021" 

# See more keys and their definitions at https://doc.rustlang.org/cargo/reference/manifest.html 
[dependencies]
```
- [*TOML*](https://toml.io/) (*Tom's Obvious, Minimal Language*) format, Cargo's configuration format
- `[package]` is a section heading that indicates that the following statements are configuring a package
- next three lines set the config information Cargo needs to compile the program
	- name
	- version
	- edition of Rust to use
- last line, `[dependencies]` is the start location to list any of your project's dependencies
- in Rust, packages of code are referred to as *crates*
---
Filename: [[Projects/hello_cargo/src/main.rs|src/main.rs]]
```rust
fn main() {
	println!("Hello, world!");
}
```
- "Hello, world!" program generated by Cargo
- differences between [[Projects/hello_world/main.rs|hello_world]] project and [[Projects/hello_cargo/src/main.rs|hello_cargo]] project
	- Cargo placed code in the *src* directory
	- *Cargo.toml* config file in top directory
- Cargo expects source files to be inside *src* directory
- top-level directory directory
	- README files
	- license information
	- anything else not related to code
- if a project was started that doesn't use Cargo, can convert to a project that does use Cargo
	- move project code into the *src* directory and create an appropriate *Cargo.toml* file
---
### Building and Running a Cargo Project
- to build project
```console
$ cargo build
```
- this commands creates an executable file in *target/debug/hello_cargo* rather than current directory
- Cargo puts binary in *debug* directory
ㅤ
ㅤ
- to run executable
```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
```

```console
Hello, world!
```

- running `cargo build` for the first time also causes Cargo to create *Cargo.lock* at the top level
	- keeps track of the exact versions of dependencies in project
	- Cargo manages its contents automatically

ㅤ
- to compile and run in one command
```console
$ cargo run
```

```console
Hello, world!
```
- `cargo run` is more convenient than using `cargo build` and  the use the whole path to the binary
- if files had been modified, Cargo would have rebuilt the project before running it
ㅤ
ㅤ
- `cargo check` to check if code compiles but doesn't produce an executable
```console
$ cargo check
```
- why to not want an executable?
	- often, `cargo check` is much faster than `cargo build` as it skips the step of producing an executable
	- if continually checking work while writing code, `cargo check` will speed up process of letting you know if it's still compiling
	- run `cargo check` periodically when writing program to make sure it compiles
	- run `cargo build` when ready to use the executable

ㅤ
- Cargo recap
	- `cargo new`: create project
	- `cargo build`: build project
	- `cargo run`: build and run project
	- `cargo check`: build project without producing binary to check for errors
	- Cargo stores build in *target/debug* directory instead of the same directory as code

---
### Building for Release
- `cargo build --release`
	- compile it with optimizations when ready for release
	- creates an executable in *target/release* instead of *target/debug*
	- optimizations makes code run faster but lengthens the time it takes to compile
	- two profiles
		- one for development
		- one for building final program
	- benchmarking
		- `cargo build --release` and benchmark with executable in *target/release*

---
### Cargo as Convention
- much easier to let Cargo coordinate the build as programs become more intricate
- can work on existing projects
```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```